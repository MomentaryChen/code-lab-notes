<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>排序演算法視覺化</title>
    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --accent: #f093fb;
            --bg-light: #f8f9fa;
            --text-dark: #333;
            --text-light: #666;
            --border: #e0e0e0;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-dark);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 40px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            color: var(--text-light);
            font-size: 1.1em;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: var(--primary);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--secondary);
        }

        .algorithm-section {
            margin-bottom: 50px;
            padding: 30px;
            background: var(--bg-light);
            border-radius: 12px;
            border-left: 5px solid var(--primary);
        }

        h2 {
            color: var(--secondary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--primary);
            font-size: 1.8em;
        }

        h3 {
            color: var(--text-dark);
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .complexity-table th,
        .complexity-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .complexity-table th {
            background: var(--primary);
            color: white;
            font-weight: 600;
        }

        .complexity-table tr:hover {
            background: #f0f0f0;
        }

        .visualization-container {
            margin: 30px 0;
            padding: 25px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .array-display {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 8px;
            min-height: 300px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .bar {
            background: linear-gradient(180deg, var(--primary), var(--secondary));
            border-radius: 4px 4px 0 0;
            min-width: 30px;
            transition: all 0.3s ease;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            padding-bottom: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .bar.comparing {
            background: var(--warning);
            transform: scaleY(1.1);
        }

        .bar.sorted {
            background: var(--success);
        }

        .bar.swapping {
            background: var(--danger);
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.15); }
        }

        .info-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid var(--primary);
        }

        .info-panel p {
            margin: 8px 0;
            color: var(--text-dark);
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
        }

        .code-block .keyword {
            color: #c678dd;
        }

        .code-block .function {
            color: #61afef;
        }

        .code-block .string {
            color: #98c379;
        }

        .code-block .comment {
            color: #5c6370;
            font-style: italic;
        }

        .step-list {
            list-style: none;
            padding-left: 0;
        }

        .step-list li {
            padding: 12px;
            margin: 8px 0;
            background: white;
            border-radius: 6px;
            border-left: 4px solid var(--primary);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .step-list li::before {
            content: "→ ";
            color: var(--primary);
            font-weight: bold;
            margin-right: 8px;
        }

        .comparison-section {
            margin-top: 40px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 12px;
        }

        .float-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .float-btn {
            min-width: 120px;
            height: 50px;
            border-radius: 25px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5), 0 0 0 2px rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            padding: 0 20px;
        }

        .float-btn.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .float-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.7), 0 0 0 2px rgba(255, 255, 255, 0.2);
        }

        .float-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .float-btn.back-btn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
        }

        .float-btn.top-btn {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--primary) 100%);
        }

        .float-btn-icon {
            font-size: 18px;
            font-weight: bold;
        }

        .float-btn-text {
            font-size: 14px;
            letter-spacing: 0.5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 2em;
            }

            .controls {
                flex-direction: column;
            }

            button {
                width: 100%;
            }

            .array-display {
                min-height: 200px;
            }

            .bar {
                min-width: 20px;
                font-size: 10px;
            }

            .float-button {
                bottom: 20px;
                right: 20px;
            }

            .float-btn {
                min-width: 100px;
                height: 44px;
                font-size: 14px;
                padding: 0 16px;
            }

            .float-btn-icon {
                font-size: 16px;
            }

            .float-btn-text {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← 返回首頁</a>
        
        <div class="header">
            <h1>排序演算法視覺化</h1>
            <p class="subtitle">透過互動式演示理解各種排序演算法的運作原理</p>
        </div>

        <!-- 冒泡排序 -->
        <div class="algorithm-section">
            <h2>1. 冒泡排序 (Bubble Sort)</h2>
            
            <h3>演算法原理</h3>
            <p>冒泡排序是一種簡單的排序演算法，它重複地遍歷要排序的數列，一次比較兩個元素，如果它們的順序錯誤就把它們交換過來。遍歷數列的工作是重複地進行直到沒有再需要交換，也就是說該數列已經排序完成。</p>

            <h3>時間複雜度</h3>
            <table class="complexity-table">
                <tr>
                    <th>情況</th>
                    <th>時間複雜度</th>
                </tr>
                <tr>
                    <td>最佳情況</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>平均情況</td>
                    <td>O(n²)</td>
                </tr>
                <tr>
                    <td>最壞情況</td>
                    <td>O(n²)</td>
                </tr>
            </table>
            <p><strong>空間複雜度：</strong>O(1)</p>

            <h3>步驟說明</h3>
            <ol class="step-list">
                <li>比較相鄰的元素。如果第一個比第二個大，就交換它們兩個。</li>
                <li>對每一對相鄰元素做同樣的工作，從開始第一對到結尾的最後一對。這步做完後，最後的元素會是最大的數。</li>
                <li>針對所有的元素重複以上的步驟，除了最後一個。</li>
                <li>持續每次對越來越少的元素重複上面的步驟，直到沒有任何一對數字需要比較。</li>
            </ol>

            <div class="visualization-container">
                <h3>互動演示</h3>
                <div class="controls">
                    <button class="btn-primary" onclick="initBubbleSort()">生成新陣列</button>
                    <button class="btn-success" onclick="startBubbleSort()">開始排序</button>
                    <button class="btn-secondary" onclick="resetBubbleSort()">重置</button>
                </div>
                <div id="bubble-display" class="array-display"></div>
                <div id="bubble-info" class="info-panel">
                    <p>點擊「生成新陣列」開始，然後點擊「開始排序」觀看動畫演示。</p>
                </div>
            </div>

            <h3>程式碼實作</h3>
            <div class="code-block">
<span class="keyword">function</span> <span class="function">bubbleSort</span>(arr) {
    <span class="keyword">let</span> n = arr.length;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < n - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j < n - i - <span class="number">1</span>; j++) {
            <span class="keyword">if</span> (arr[j] > arr[j + <span class="number">1</span>]) {
                <span class="comment">// 交換元素</span>
                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];
            }
        }
    }
    <span class="keyword">return</span> arr;
}
            </div>
        </div>

        <!-- 快速排序 -->
        <div class="algorithm-section">
            <h2>2. 快速排序 (Quick Sort)</h2>
            
            <h3>演算法原理</h3>
            <p>快速排序是一種分治演算法。它從數列中挑出一個元素作為「基準」（pivot），重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面。在這個分割結束之後，該基準就處於數列的中間位置。這個稱為分割（partition）操作。遞迴地（recursive）把小於基準值元素的子數列和大於基準值元素的子數列排序。</p>

            <h3>時間複雜度</h3>
            <table class="complexity-table">
                <tr>
                    <th>情況</th>
                    <th>時間複雜度</th>
                </tr>
                <tr>
                    <td>最佳情況</td>
                    <td>O(n log n)</td>
                </tr>
                <tr>
                    <td>平均情況</td>
                    <td>O(n log n)</td>
                </tr>
                <tr>
                    <td>最壞情況</td>
                    <td>O(n²)</td>
                </tr>
            </table>
            <p><strong>空間複雜度：</strong>O(log n)</p>

            <h3>步驟說明</h3>
            <ol class="step-list">
                <li>選擇一個基準元素（通常選擇第一個或最後一個元素）。</li>
                <li>重新排列數列，使得所有比基準小的元素都在基準左邊，所有比基準大的元素都在基準右邊。</li>
                <li>遞迴地對基準左邊和右邊的子數列進行排序。</li>
            </ol>

            <div class="visualization-container">
                <h3>互動演示</h3>
                <div class="controls">
                    <button class="btn-primary" onclick="initQuickSort()">生成新陣列</button>
                    <button class="btn-success" onclick="startQuickSort()">開始排序</button>
                    <button class="btn-secondary" onclick="resetQuickSort()">重置</button>
                </div>
                <div id="quick-display" class="array-display"></div>
                <div id="quick-info" class="info-panel">
                    <p>點擊「生成新陣列」開始，然後點擊「開始排序」觀看動畫演示。</p>
                </div>
            </div>

            <h3>程式碼實作</h3>
            <div class="code-block">
<span class="keyword">function</span> <span class="function">quickSort</span>(arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span>) {
    <span class="keyword">if</span> (left < right) {
        <span class="keyword">let</span> pivotIndex = <span class="function">partition</span>(arr, left, right);
        <span class="function">quickSort</span>(arr, left, pivotIndex - <span class="number">1</span>);
        <span class="function">quickSort</span>(arr, pivotIndex + <span class="number">1</span>, right);
    }
    <span class="keyword">return</span> arr;
}

<span class="keyword">function</span> <span class="function">partition</span>(arr, left, right) {
    <span class="keyword">let</span> pivot = arr[right];
    <span class="keyword">let</span> i = left - <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j < right; j++) {
        <span class="keyword">if</span> (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    [arr[i + <span class="number">1</span>], arr[right]] = [arr[right], arr[i + <span class="number">1</span>]];
    <span class="keyword">return</span> i + <span class="number">1</span>;
}
            </div>
        </div>

        <!-- 歸併排序 -->
        <div class="algorithm-section">
            <h2>3. 歸併排序 (Merge Sort)</h2>
            
            <h3>演算法原理</h3>
            <p>歸併排序是建立在歸併操作上的一種有效的排序演算法。該演算法採用分治法（Divide and Conquer）的一個非常典型的應用。將已有序的子序列合併，得到完全有序的序列；即先使每個子序列有序，再使子序列段間有序。</p>

            <h3>時間複雜度</h3>
            <table class="complexity-table">
                <tr>
                    <th>情況</th>
                    <th>時間複雜度</th>
                </tr>
                <tr>
                    <td>最佳情況</td>
                    <td>O(n log n)</td>
                </tr>
                <tr>
                    <td>平均情況</td>
                    <td>O(n log n)</td>
                </tr>
                <tr>
                    <td>最壞情況</td>
                    <td>O(n log n)</td>
                </tr>
            </table>
            <p><strong>空間複雜度：</strong>O(n)</p>

            <h3>步驟說明</h3>
            <ol class="step-list">
                <li>將數列分成兩半，直到每個子數列只有一個元素。</li>
                <li>遞迴地對兩個子數列進行歸併排序。</li>
                <li>合併兩個已排序的子數列，形成一個新的有序數列。</li>
            </ol>

            <div class="visualization-container">
                <h3>互動演示</h3>
                <div class="controls">
                    <button class="btn-primary" onclick="initMergeSort()">生成新陣列</button>
                    <button class="btn-success" onclick="startMergeSort()">開始排序</button>
                    <button class="btn-secondary" onclick="resetMergeSort()">重置</button>
                </div>
                <div id="merge-display" class="array-display"></div>
                <div id="merge-info" class="info-panel">
                    <p>點擊「生成新陣列」開始，然後點擊「開始排序」觀看動畫演示。</p>
                </div>
            </div>

            <h3>程式碼實作</h3>
            <div class="code-block">
<span class="keyword">function</span> <span class="function">mergeSort</span>(arr) {
    <span class="keyword">if</span> (arr.length <= <span class="number">1</span>) {
        <span class="keyword">return</span> arr;
    }
    <span class="keyword">let</span> mid = Math.floor(arr.length / <span class="number">2</span>);
    <span class="keyword">let</span> left = <span class="function">mergeSort</span>(arr.slice(<span class="number">0</span>, mid));
    <span class="keyword">let</span> right = <span class="function">mergeSort</span>(arr.slice(mid));
    <span class="keyword">return</span> <span class="function">merge</span>(left, right);
}

<span class="keyword">function</span> <span class="function">merge</span>(left, right) {
    <span class="keyword">let</span> result = [];
    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;
    <span class="keyword">while</span> (i < left.length && j < right.length) {
        <span class="keyword">if</span> (left[i] <= right[j]) {
            result.push(left[i++]);
        } <span class="keyword">else</span> {
            result.push(right[j++]);
        }
    }
    <span class="keyword">return</span> result.concat(left.slice(i)).concat(right.slice(j));
}
            </div>
        </div>

        <!-- 選擇排序 -->
        <div class="algorithm-section">
            <h2>4. 選擇排序 (Selection Sort)</h2>
            
            <h3>演算法原理</h3>
            <p>選擇排序是一種簡單直觀的排序演算法。它的工作原理是：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然後，再從剩餘未排序元素中繼續尋找最小（大）元素，然後放到已排序序列的末尾。以此類推，直到所有元素均排序完畢。</p>

            <h3>時間複雜度</h3>
            <table class="complexity-table">
                <tr>
                    <th>情況</th>
                    <th>時間複雜度</th>
                </tr>
                <tr>
                    <td>最佳情況</td>
                    <td>O(n²)</td>
                </tr>
                <tr>
                    <td>平均情況</td>
                    <td>O(n²)</td>
                </tr>
                <tr>
                    <td>最壞情況</td>
                    <td>O(n²)</td>
                </tr>
            </table>
            <p><strong>空間複雜度：</strong>O(1)</p>

            <h3>步驟說明</h3>
            <ol class="step-list">
                <li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
                <li>從剩餘未排序元素中繼續尋找最小（大）元素。</li>
                <li>將找到的最小元素與當前位置的元素交換。</li>
                <li>重複步驟 2-3，直到所有元素均排序完畢。</li>
            </ol>

            <div class="visualization-container">
                <h3>互動演示</h3>
                <div class="controls">
                    <button class="btn-primary" onclick="initSelectionSort()">生成新陣列</button>
                    <button class="btn-success" onclick="startSelectionSort()">開始排序</button>
                    <button class="btn-secondary" onclick="resetSelectionSort()">重置</button>
                </div>
                <div id="selection-display" class="array-display"></div>
                <div id="selection-info" class="info-panel">
                    <p>點擊「生成新陣列」開始，然後點擊「開始排序」觀看動畫演示。</p>
                </div>
            </div>

            <h3>程式碼實作</h3>
            <div class="code-block">
<span class="keyword">function</span> <span class="function">selectionSort</span>(arr) {
    <span class="keyword">let</span> n = arr.length;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < n - <span class="number">1</span>; i++) {
        <span class="keyword">let</span> minIdx = i;
        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j < n; j++) {
            <span class="keyword">if</span> (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        <span class="keyword">if</span> (minIdx !== i) {
            [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
        }
    }
    <span class="keyword">return</span> arr;
}
            </div>
        </div>

        <!-- 插入排序 -->
        <div class="algorithm-section">
            <h2>5. 插入排序 (Insertion Sort)</h2>
            
            <h3>演算法原理</h3>
            <p>插入排序是一種簡單直觀的排序演算法。它的工作原理是通過構建有序序列，對於未排序數據，在已排序序列中從後向前掃描，找到相應位置並插入。插入排序在實現上，通常採用 in-place 排序（即只需用到 O(1) 的額外空間的排序），因而在從後向前掃描過程中，需要反覆把已排序元素逐步向後挪位，為最新元素提供插入空間。</p>

            <h3>時間複雜度</h3>
            <table class="complexity-table">
                <tr>
                    <th>情況</th>
                    <th>時間複雜度</th>
                </tr>
                <tr>
                    <td>最佳情況</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>平均情況</td>
                    <td>O(n²)</td>
                </tr>
                <tr>
                    <td>最壞情況</td>
                    <td>O(n²)</td>
                </tr>
            </table>
            <p><strong>空間複雜度：</strong>O(1)</p>

            <h3>步驟說明</h3>
            <ol class="step-list">
                <li>從第一個元素開始，該元素可以認為已經被排序。</li>
                <li>取出下一個元素，在已經排序的元素序列中從後向前掃描。</li>
                <li>如果該元素（已排序）大於新元素，將該元素移到下一位置。</li>
                <li>重複步驟 3，直到找到已排序的元素小於或者等於新元素的位置。</li>
                <li>將新元素插入到該位置後。</li>
                <li>重複步驟 2-5。</li>
            </ol>

            <div class="visualization-container">
                <h3>互動演示</h3>
                <div class="controls">
                    <button class="btn-primary" onclick="initInsertionSort()">生成新陣列</button>
                    <button class="btn-success" onclick="startInsertionSort()">開始排序</button>
                    <button class="btn-secondary" onclick="resetInsertionSort()">重置</button>
                </div>
                <div id="insertion-display" class="array-display"></div>
                <div id="insertion-info" class="info-panel">
                    <p>點擊「生成新陣列」開始，然後點擊「開始排序」觀看動畫演示。</p>
                </div>
            </div>

            <h3>程式碼實作</h3>
            <div class="code-block">
<span class="keyword">function</span> <span class="function">insertionSort</span>(arr) {
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i < arr.length; i++) {
        <span class="keyword">let</span> key = arr[i];
        <span class="keyword">let</span> j = i - <span class="number">1</span>;
        <span class="keyword">while</span> (j >= <span class="number">0</span> && arr[j] > key) {
            arr[j + <span class="number">1</span>] = arr[j];
            j--;
        }
        arr[j + <span class="number">1</span>] = key;
    }
    <span class="keyword">return</span> arr;
}
            </div>
        </div>

        <!-- 演算法比較 -->
        <div class="comparison-section">
            <h2>演算法比較總結</h2>
            <table class="complexity-table">
                <tr>
                    <th>演算法</th>
                    <th>最佳情況</th>
                    <th>平均情況</th>
                    <th>最壞情況</th>
                    <th>空間複雜度</th>
                    <th>穩定性</th>
                </tr>
                <tr>
                    <td>冒泡排序</td>
                    <td>O(n)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                    <td>穩定</td>
                </tr>
                <tr>
                    <td>快速排序</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n²)</td>
                    <td>O(log n)</td>
                    <td>不穩定</td>
                </tr>
                <tr>
                    <td>歸併排序</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n)</td>
                    <td>穩定</td>
                </tr>
                <tr>
                    <td>選擇排序</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                    <td>不穩定</td>
                </tr>
                <tr>
                    <td>插入排序</td>
                    <td>O(n)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                    <td>穩定</td>
                </tr>
            </table>

            <h3>選擇建議</h3>
            <ul class="step-list">
                <li><strong>小數據量（&lt; 50 元素）：</strong>插入排序或選擇排序，實作簡單且效率足夠。</li>
                <li><strong>中等數據量（50-1000 元素）：</strong>快速排序或歸併排序，時間複雜度較優。</li>
                <li><strong>大數據量（&gt; 1000 元素）：</strong>歸併排序或快速排序，但要注意快速排序的最壞情況。</li>
                <li><strong>需要穩定性：</strong>選擇冒泡排序、插入排序或歸併排序。</li>
                <li><strong>空間受限：</strong>選擇冒泡排序、選擇排序或插入排序（O(1) 空間複雜度）。</li>
            </ul>
        </div>
    </div>

    <script>
        // 通用函數：生成隨機陣列
        function generateRandomArray(size = 10, min = 10, max = 200) {
            return Array.from({ length: size }, () => 
                Math.floor(Math.random() * (max - min + 1)) + min
            );
        }

        // 通用函數：渲染陣列
        function renderArray(displayId, arr, highlights = {}) {
            const display = document.getElementById(displayId);
            display.innerHTML = '';
            const maxHeight = Math.max(...arr);
            
            arr.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${(value / maxHeight) * 100}%`;
                bar.textContent = value;
                
                if (highlights.comparing && highlights.comparing.includes(index)) {
                    bar.classList.add('comparing');
                }
                if (highlights.swapping && highlights.swapping.includes(index)) {
                    bar.classList.add('swapping');
                }
                if (highlights.sorted && highlights.sorted.includes(index)) {
                    bar.classList.add('sorted');
                }
                
                display.appendChild(bar);
            });
        }

        // 通用函數：延遲
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // 冒泡排序
        let bubbleArray = [];
        let bubbleSorting = false;

        function initBubbleSort() {
            bubbleArray = generateRandomArray(12);
            renderArray('bubble-display', bubbleArray);
            document.getElementById('bubble-info').innerHTML = 
                '<p>陣列已生成，點擊「開始排序」觀看動畫演示。</p>';
        }

        async function startBubbleSort() {
            if (bubbleSorting) return;
            bubbleSorting = true;
            const info = document.getElementById('bubble-info');
            const arr = [...bubbleArray];
            const n = arr.length;
            let comparisons = 0;
            let swaps = 0;

            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    comparisons++;
                    renderArray('bubble-display', arr, {
                        comparing: [j, j + 1],
                        sorted: Array.from({ length: i }, (_, k) => n - 1 - k)
                    });
                    info.innerHTML = `<p>比較次數: ${comparisons} | 交換次數: ${swaps} | 比較元素: ${arr[j]} 和 ${arr[j + 1]}</p>`;
                    await delay(300);

                    if (arr[j] > arr[j + 1]) {
                        swaps++;
                        renderArray('bubble-display', arr, {
                            swapping: [j, j + 1],
                            sorted: Array.from({ length: i }, (_, k) => n - 1 - k)
                        });
                        await delay(200);
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                    }
                }
            }

            renderArray('bubble-display', arr, { sorted: arr.map((_, i) => i) });
            info.innerHTML = `<p><strong>排序完成！</strong> 總比較次數: ${comparisons} | 總交換次數: ${swaps}</p>`;
            bubbleSorting = false;
        }

        function resetBubbleSort() {
            bubbleSorting = false;
            initBubbleSort();
        }

        // 快速排序
        let quickArray = [];
        let quickSorting = false;

        function initQuickSort() {
            quickArray = generateRandomArray(12);
            renderArray('quick-display', quickArray);
            document.getElementById('quick-info').innerHTML = 
                '<p>陣列已生成，點擊「開始排序」觀看動畫演示。</p>';
        }

        async function quickSortVisual(arr, left, right, displayId, infoId) {
            if (left >= right) return;
            
            const pivot = arr[right];
            let i = left - 1;
            
            for (let j = left; j < right; j++) {
                renderArray(displayId, arr, {
                    comparing: [j, right],
                    swapping: i >= left ? [i] : []
                });
                document.getElementById(infoId).innerHTML = 
                    `<p>選擇基準: ${pivot} | 比較元素: ${arr[j]} 與基準</p>`;
                await delay(400);

                if (arr[j] < pivot) {
                    i++;
                    if (i !== j) {
                        renderArray(displayId, arr, { swapping: [i, j] });
                        await delay(300);
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                }
            }
            
            [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
            renderArray(displayId, arr, { swapping: [i + 1, right] });
            await delay(300);
            
            await quickSortVisual(arr, left, i, displayId, infoId);
            await quickSortVisual(arr, i + 2, right, displayId, infoId);
        }

        async function startQuickSort() {
            if (quickSorting) return;
            quickSorting = true;
            const arr = [...quickArray];
            await quickSortVisual(arr, 0, arr.length - 1, 'quick-display', 'quick-info');
            renderArray('quick-display', arr, { sorted: arr.map((_, i) => i) });
            document.getElementById('quick-info').innerHTML = 
                '<p><strong>排序完成！</strong></p>';
            quickSorting = false;
        }

        function resetQuickSort() {
            quickSorting = false;
            initQuickSort();
        }

        // 歸併排序
        let mergeArray = [];
        let mergeSorting = false;

        function initMergeSort() {
            mergeArray = generateRandomArray(12);
            renderArray('merge-display', mergeArray);
            document.getElementById('merge-info').innerHTML = 
                '<p>陣列已生成，點擊「開始排序」觀看動畫演示。</p>';
        }

        async function mergeSortVisual(arr, left, right, displayId, infoId, originalArr) {
            if (left >= right) return;
            
            const mid = Math.floor((left + right) / 2);
            await mergeSortVisual(arr, left, mid, displayId, infoId, originalArr);
            await mergeSortVisual(arr, mid + 1, right, displayId, infoId, originalArr);
            
            const leftArr = arr.slice(left, mid + 1);
            const rightArr = arr.slice(mid + 1, right + 1);
            
            let i = 0, j = 0, k = left;
            
            while (i < leftArr.length && j < rightArr.length) {
                renderArray(displayId, arr, {
                    comparing: [left + i, mid + 1 + j]
                });
                document.getElementById(infoId).innerHTML = 
                    `<p>合併階段 | 比較: ${leftArr[i]} 和 ${rightArr[j]}</p>`;
                await delay(400);
                
                if (leftArr[i] <= rightArr[j]) {
                    arr[k++] = leftArr[i++];
                } else {
                    arr[k++] = rightArr[j++];
                }
                renderArray(displayId, arr);
                await delay(200);
            }
            
            while (i < leftArr.length) {
                arr[k++] = leftArr[i++];
                renderArray(displayId, arr);
                await delay(200);
            }
            
            while (j < rightArr.length) {
                arr[k++] = rightArr[j++];
                renderArray(displayId, arr);
                await delay(200);
            }
        }

        async function startMergeSort() {
            if (mergeSorting) return;
            mergeSorting = true;
            const arr = [...mergeArray];
            await mergeSortVisual(arr, 0, arr.length - 1, 'merge-display', 'merge-info', mergeArray);
            renderArray('merge-display', arr, { sorted: arr.map((_, i) => i) });
            document.getElementById('merge-info').innerHTML = 
                '<p><strong>排序完成！</strong></p>';
            mergeSorting = false;
        }

        function resetMergeSort() {
            mergeSorting = false;
            initMergeSort();
        }

        // 選擇排序
        let selectionArray = [];
        let selectionSorting = false;

        function initSelectionSort() {
            selectionArray = generateRandomArray(12);
            renderArray('selection-display', selectionArray);
            document.getElementById('selection-info').innerHTML = 
                '<p>陣列已生成，點擊「開始排序」觀看動畫演示。</p>';
        }

        async function startSelectionSort() {
            if (selectionSorting) return;
            selectionSorting = true;
            const arr = [...selectionArray];
            const n = arr.length;
            const info = document.getElementById('selection-info');
            let comparisons = 0;
            let swaps = 0;

            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                
                for (let j = i + 1; j < n; j++) {
                    comparisons++;
                    renderArray('selection-display', arr, {
                        comparing: [j, minIdx],
                        sorted: Array.from({ length: i }, (_, k) => k)
                    });
                    info.innerHTML = `<p>比較次數: ${comparisons} | 交換次數: ${swaps} | 尋找最小值</p>`;
                    await delay(300);
                    
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                
                if (minIdx !== i) {
                    swaps++;
                    renderArray('selection-display', arr, {
                        swapping: [i, minIdx],
                        sorted: Array.from({ length: i }, (_, k) => k)
                    });
                    await delay(300);
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                }
            }

            renderArray('selection-display', arr, { sorted: arr.map((_, i) => i) });
            info.innerHTML = `<p><strong>排序完成！</strong> 總比較次數: ${comparisons} | 總交換次數: ${swaps}</p>`;
            selectionSorting = false;
        }

        function resetSelectionSort() {
            selectionSorting = false;
            initSelectionSort();
        }

        // 插入排序
        let insertionArray = [];
        let insertionSorting = false;

        function initInsertionSort() {
            insertionArray = generateRandomArray(12);
            renderArray('insertion-display', insertionArray);
            document.getElementById('insertion-info').innerHTML = 
                '<p>陣列已生成，點擊「開始排序」觀看動畫演示。</p>';
        }

        async function startInsertionSort() {
            if (insertionSorting) return;
            insertionSorting = true;
            const arr = [...insertionArray];
            const info = document.getElementById('insertion-info');
            let comparisons = 0;
            let shifts = 0;

            for (let i = 1; i < arr.length; i++) {
                const key = arr[i];
                let j = i - 1;
                
                renderArray('insertion-display', arr, {
                    comparing: [i],
                    sorted: Array.from({ length: i }, (_, k) => k)
                });
                info.innerHTML = `<p>插入元素: ${key} | 比較次數: ${comparisons} | 移動次數: ${shifts}</p>`;
                await delay(400);

                while (j >= 0 && arr[j] > key) {
                    comparisons++;
                    renderArray('insertion-display', arr, {
                        comparing: [j, j + 1],
                        sorted: Array.from({ length: i }, (_, k) => k)
                    });
                    await delay(300);
                    
                    arr[j + 1] = arr[j];
                    shifts++;
                    j--;
                    renderArray('insertion-display', arr);
                    await delay(200);
                }
                
                arr[j + 1] = key;
                renderArray('insertion-display', arr, {
                    sorted: Array.from({ length: i + 1 }, (_, k) => k)
                });
                await delay(300);
            }

            renderArray('insertion-display', arr, { sorted: arr.map((_, i) => i) });
            info.innerHTML = `<p><strong>排序完成！</strong> 總比較次數: ${comparisons} | 總移動次數: ${shifts}</p>`;
            insertionSorting = false;
        }

        function resetInsertionSort() {
            insertionSorting = false;
            initInsertionSort();
        }

        // 初始化所有排序
        window.addEventListener('DOMContentLoaded', () => {
            initBubbleSort();
            initQuickSort();
            initMergeSort();
            initSelectionSort();
            initInsertionSort();
        });
    </script>

    <!-- 浮动按钮 -->
    <div class="float-button">
        <button class="float-btn back-btn" id="back-btn" title="返回上一页">
            <span class="float-btn-icon">←</span>
            <span class="float-btn-text">返回</span>
        </button>
        <button class="float-btn top-btn" id="top-btn" title="回到顶部">
            <span class="float-btn-icon">↑</span>
            <span class="float-btn-text">顶部</span>
        </button>
    </div>

    <script>
        // 浮动按钮功能 - 确保在 DOM 加载后执行
        document.addEventListener('DOMContentLoaded', function() {
            const floatButtons = document.querySelectorAll('.float-btn');
            const topBtn = document.getElementById('top-btn');
            const backBtn = document.getElementById('back-btn');

            // 显示/隐藏浮动按钮
            function toggleFloatButtons() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                floatButtons.forEach(btn => {
                    if (scrollTop > 300) {
                        btn.classList.add('show');
                    } else {
                        btn.classList.remove('show');
                    }
                });
            }

            // 回到顶部
            if (topBtn) {
                topBtn.addEventListener('click', () => {
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                });
            }

            // 返回上一页
            if (backBtn) {
                backBtn.addEventListener('click', () => {
                    if (document.referrer && document.referrer !== window.location.href) {
                        window.history.back();
                    } else {
                        window.location.href = 'index.html';
                    }
                });
            }

            // 监听滚动事件
            window.addEventListener('scroll', toggleFloatButtons);
            toggleFloatButtons(); // 初始检查
            
            // 如果页面已经滚动，立即显示按钮
            if (window.pageYOffset > 300) {
                floatButtons.forEach(btn => btn.classList.add('show'));
            }
        });
    </script>
</body>
</html>
