<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>Algorithm Visualizations</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            color-scheme: light dark;
            --bg-color: #0f172a;
            --card-bg: #020617;
            --accent: #38bdf8;
            --accent-soft: rgba(56, 189, 248, 0.1);
            --text-main: #e5e7eb;
            --text-sub: #9ca3af;
            --border-subtle: rgba(148, 163, 184, 0.35);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top left, #1d283a, #020617 55%);
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            align-items: stretch;
            justify-content: center;
        }

        .page {
            width: 100%;
            max-width: 1200px;
            padding: 32px 20px 40px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 16px;
        }

        .title-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 3px 10px;
            font-size: 11px;
            border-radius: 999px;
            background: var(--accent-soft);
            color: var(--accent);
            border: 1px solid rgba(56, 189, 248, 0.25);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        h1 {
            margin: 0;
            font-size: clamp(24px, 4vw, 30px);
            letter-spacing: 0.02em;
        }

        .subtitle {
            margin: 0;
            font-size: 14px;
            color: var(--text-sub);
            max-width: 640px;
        }

        .meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            font-size: 12px;
            color: var(--text-sub);
        }

        .meta-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: var(--accent);
            box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.2);
        }

        main {
            display: grid;
            grid-template-columns: minmax(0, 2.1fr) minmax(0, 1.1fr);
            gap: 20px;
        }

        .algorithms-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            grid-column: 1;
        }

        @media (max-width: 880px) {
            main {
                grid-template-columns: minmax(0, 1fr);
            }
            .meta {
                align-items: flex-start;
            }
            .algorithms-grid {
                grid-column: 1;
            }
        }

        .card {
            border-radius: 18px;
            border: 1px solid var(--border-subtle);
            background: radial-gradient(circle at top left, rgba(148, 163, 184, 0.28), rgba(15, 23, 42, 0.96));
            padding: 18px 18px 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow:
                    0 18px 45px rgba(0, 0, 0, 0.65),
                    0 0 0 0.5px rgba(15, 23, 42, 0.9);
            cursor: pointer;
            transition:
                    transform 160ms ease-out,
                    box-shadow 160ms ease-out,
                    border-color 160ms ease-out,
                    background 160ms ease-out;
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow:
                    0 22px 55px rgba(15, 23, 42, 0.9),
                    0 0 0 0.5px rgba(56, 189, 248, 0.9);
            border-color: rgba(56, 189, 248, 0.7);
        }

        .card:focus-visible {
            outline: none;
            transform: translateY(-2px);
            box-shadow:
                    0 0 0 2px rgba(56, 189, 248, 0.9),
                    0 18px 45px rgba(15, 23, 42, 0.9);
            border-color: rgba(56, 189, 248, 0.85);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .card-title {
            font-size: 15px;
            font-weight: 600;
        }

        .chip-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 4px;
        }

        .chip {
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-sub);
        }

        .preview {
            position: relative;
            overflow: hidden;
            border-radius: 14px;
            border: 1px solid rgba(15, 23, 42, 0.9);
            background: radial-gradient(circle at top, #1f2937, #020617);
            box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.9);
            aspect-ratio: 16 / 9;
        }

        .preview img,
        .preview canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform-origin: center;
            transition: transform 220ms ease-out;
        }

        .preview::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.16), transparent 55%);
            mix-blend-mode: screen;
            pointer-events: none;
        }

        .card:hover .preview img,
        .card:hover .preview canvas {
            transform: scale(1.025);
        }

        .card-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-top: 4px;
        }

        .description {
            font-size: 12px;
            line-height: 1.6;
            color: var(--text-sub);
        }

        .primary-action {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 7px 14px;
            border-radius: 999px;
            border: none;
            background: linear-gradient(135deg, #38bdf8, #4f46e5);
            color: #0b1120;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            box-shadow:
                    0 0 0 1px rgba(15, 23, 42, 0.9),
                    0 10px 22px rgba(37, 99, 235, 0.6);
        }

        .primary-action span.icon {
            font-size: 13px;
        }

        .primary-action:active {
            transform: translateY(1px);
            box-shadow:
                    0 0 0 1px rgba(15, 23, 42, 0.9),
                    0 6px 16px rgba(37, 99, 235, 0.7);
        }

        .secondary-links {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 11px;
        }

        .secondary-links a {
            color: var(--text-sub);
            text-decoration: none;
            border-bottom: 1px dashed rgba(148, 163, 184, 0.7);
        }

        .secondary-links a:hover {
            color: var(--accent);
            border-bottom-style: solid;
        }

        .side-panel {
            border-radius: 18px;
            border: 1px solid rgba(148, 163, 184, 0.45);
            background: radial-gradient(circle at top right, rgba(59, 130, 246, 0.28), rgba(15, 23, 42, 0.98));
            padding: 16px 16px 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow:
                    0 16px 40px rgba(15, 23, 42, 0.95),
                    0 0 0 0.5px rgba(15, 23, 42, 0.9);
        }

        .side-title {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--accent);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.5);
        }

        .side-title::after {
            content: 'ALGOS';
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.7);
            color: var(--text-sub);
        }

        .side-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            color: var(--text-sub);
        }

        .side-list li {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 10px;
            transition: background 0.18s ease-out, transform 0.18s ease-out;
        }

        .side-list li:hover {
            background: rgba(15, 23, 42, 0.7);
            transform: translateX(2px);
        }

        .side-list a {
            color: var(--accent);
            font-weight: 500;
            text-decoration: none;
        }

        .side-list a:hover {
            text-decoration: underline;
        }

        .side-bullet {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-top: 4px;
            background: linear-gradient(135deg, #38bdf8, #22c55e);
            box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.18);
        }

        .side-footer {
            margin-top: 4px;
            font-size: 11px;
            color: var(--text-sub);
            opacity: 0.9;
        }
    </style>
</head>
<body>
<div class="page">
    <header>
        <div class="title-group">
            <div class="badge">
                <span>Algorithm Lab</span>
            </div>
            <h1>演算法視覺化實驗室</h1>
            <p class="subtitle">
                透過互動式網頁與圖像，直觀理解 A* 等路徑搜尋演算法的運作方式。本首頁會帶你前往各個演算法說明頁面。
            </p>
        </div>
    </header>

    <main>
        <div class="algorithms-grid">
            <section class="card" data-href="src/astar-algorithm-explanation.html">
                <div class="card-header">
                    <div>
                        <div class="card-title">A*（A-star）路徑搜尋演算法</div>
                        <div class="chip-row">
                            <div class="chip">Pathfinding</div>
                            <div class="chip">Heuristic Search</div>
                            <div class="chip">Grid Visualization</div>
                        </div>
                    </div>
                </div>

                <div class="preview">
                    <a href="src/astar-algorithm-explanation.html" aria-label="前往 A* 演算法說明頁">
                        <canvas id="astar-preview" width="800" height="400"></canvas>
                    </a>
                </div>

                <div class="card-footer">
                    <p class="description">
                        透過網格地圖、起點與終點、障礙物與已探索節點的視覺化標記，觀察 A* 如何在考量實際距離與啟發式估計的情況下，
                        漸進式逼近最短路徑。
                    </p>
                </div>

                <div class="card-footer">
                    <a class="primary-action" href="src/astar-algorithm-explanation.html">
                        <span class="icon">▶</span>
                        <span>開始體驗 A* 說明</span>
                    </a>
                    <div class="secondary-links">
                        <a href="src/astar-algorithm-explanation.html" target="_blank" rel="noopener noreferrer">演算法詳解</a>
                    </div>
                </div>
            </section>

            <section class="card" data-href="src/sorting-algorithms.html">
                <div class="card-header">
                    <div>
                        <div class="card-title">排序演算法視覺化</div>
                        <div class="chip-row">
                            <div class="chip">Sorting</div>
                            <div class="chip">Interactive Demo</div>
                            <div class="chip">Visualization</div>
                        </div>
                    </div>
                </div>

                <div class="preview">
                    <a href="src/sorting-algorithms.html" aria-label="前往排序演算法說明頁">
                        <canvas id="sorting-preview" width="800" height="400"></canvas>
                    </a>
                </div>

                <div class="card-footer">
                    <p class="description">
                        包含冒泡排序、快速排序、歸併排序、選擇排序、插入排序等五種常見排序演算法的互動式視覺化演示，
                        每個演算法都包含詳細說明、時間複雜度分析和程式碼實作。
                    </p>
                </div>

                <div class="card-footer">
                    <a class="primary-action" href="src/sorting-algorithms.html">
                        <span class="icon">▶</span>
                        <span>開始體驗排序演算法</span>
                    </a>
                    <div class="secondary-links">
                        <a href="src/sorting-algorithms.html#comparison-section" target="_blank" rel="noopener noreferrer">演算法比較</a>
                    </div>
                </div>
            </section>
        </div>

        <aside class="side-panel">
            <div class="side-title">所有演算法列表</div>
            <ul class="side-list">
                <li>
                    <div class="side-bullet"></div>
                    <div>
                        <a href="src/astar-algorithm-explanation.html">A* 路徑搜尋演算法</a>
                        <div>啟發式最短路徑搜尋，適用於網格、地圖等場景。</div>
                    </div>
                </li>
                <li>
                    <div class="side-bullet"></div>
                    <div>
                        <a href="src/sorting-algorithms.html">排序演算法視覺化</a>
                        <div>冒泡、快速、歸併、選擇、插入等常見排序的比較與動畫演示。</div>
                    </div>
                </li>
                <li>
                    <div class="side-bullet"></div>
                    <div>
                        <span>更多演算法（預留）</span>
                        <div>可在此處加入搜尋、圖論、動態規劃等其他演算法頁面。</div>
                    </div>
                </li>
            </ul>
            <div class="side-footer">
                從右側面板可快速切換到不同演算法說明頁，方便教學與練習。
            </div>
        </aside>
    </main>
</div>

<script>
    // 生成 A* 演算法預覽圖
    function generateAStarPreview() {
        const canvas = document.getElementById('astar-preview');
        if (!canvas) return;
        
        // 設定 Canvas 尺寸（高解析度）
        const dpr = window.devicePixelRatio || 1;
        const container = canvas.parentElement;
        const displayWidth = container.clientWidth || 800;
        // 使用容器的实际高度（CSS aspect-ratio 会自动计算）
        const displayHeight = container.clientHeight || Math.floor(displayWidth * 9 / 16);
        
        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        
        const width = displayWidth;
        const height = displayHeight;
        
        // 建立漸層背景
        const bgGradient = ctx.createLinearGradient(0, 0, width, height);
        bgGradient.addColorStop(0, '#1a237e');
        bgGradient.addColorStop(1, '#283593');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, width, height);
        
        // 绘制标题
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = `bold ${Math.floor(width / 25)}px "Microsoft YaHei", sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText('A* 路徑搜尋演算法', width / 2, height * 0.12);
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = `${Math.floor(width / 45)}px "Microsoft YaHei", sans-serif`;
        ctx.fillText('啟發式最短路徑搜尋', width / 2, height * 0.21);
        
        // 繪製網格地圖（根據高度動態縮放，避免被裁切）
        const gridSize = 10;
        const gridHeight = height * 0.55; // 預留空間給標題與圖例
        const cellSize = gridHeight / gridSize;
        const gridStartX = (width - gridSize * cellSize) / 2;
        const gridStartY = height * 0.28;
        
        // 繪製網格背景
        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                const x = gridStartX + col * cellSize;
                const y = gridStartY + row * cellSize;
                
                // 绘制单元格
                ctx.fillStyle = (row + col) % 2 === 0 ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)';
                ctx.fillRect(x, y, cellSize, cellSize);
                
                // 绘制边框
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, cellSize, cellSize);
            }
        }
        
        // 定義路徑點（起點、終點、障礙物、路徑）
        const startPos = { row: 1, col: 1 };
        const endPos = { row: 8, col: 8 };
        const walls = [
            { row: 3, col: 3 }, { row: 3, col: 4 }, { row: 3, col: 5 },
            { row: 4, col: 5 }, { row: 5, col: 5 }, { row: 6, col: 5 },
            { row: 6, col: 4 }, { row: 6, col: 3 }
        ];
        const path = [
            { row: 1, col: 1 }, { row: 1, col: 2 }, { row: 2, col: 2 },
            { row: 2, col: 3 }, { row: 2, col: 4 }, { row: 2, col: 5 },
            { row: 2, col: 6 }, { row: 3, col: 6 }, { row: 4, col: 6 },
            { row: 5, col: 6 }, { row: 6, col: 6 }, { row: 7, col: 6 },
            { row: 7, col: 7 }, { row: 8, col: 7 }, { row: 8, col: 8 }
        ];
        const explored = [
            { row: 0, col: 1 }, { row: 1, col: 0 }, { row: 0, col: 2 },
            { row: 2, col: 1 }, { row: 3, col: 2 }, { row: 4, col: 2 },
            { row: 5, col: 2 }, { row: 4, col: 3 }, { row: 4, col: 4 },
            { row: 5, col: 3 }, { row: 5, col: 4 }, { row: 7, col: 5 },
            { row: 8, col: 6 }, { row: 7, col: 8 }, { row: 9, col: 7 }
        ];
        
        // 繪製已探索的節點（淺綠色）
        explored.forEach(cell => {
            if (!walls.some(w => w.row === cell.row && w.col === cell.col) &&
                !path.some(p => p.row === cell.row && p.col === cell.col) &&
                (cell.row !== startPos.row || cell.col !== startPos.col) &&
                (cell.row !== endPos.row || cell.col !== endPos.col)) {
                const x = gridStartX + cell.col * cellSize;
                const y = gridStartY + cell.row * cellSize;
                ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                ctx.fillRect(x, y, cellSize, cellSize);
            }
        });
        
        // 繪製路徑（藍色）
        path.forEach((cell, index) => {
            if (index > 0 && index < path.length - 1) {
                const x = gridStartX + cell.col * cellSize;
                const y = gridStartY + cell.row * cellSize;
                ctx.fillStyle = 'rgba(33, 150, 243, 0.6)';
                ctx.fillRect(x, y, cellSize, cellSize);
                
                // 绘制路径连接线
                if (index < path.length - 1) {
                    const next = path[index + 1];
                    const nextX = gridStartX + next.col * cellSize + cellSize / 2;
                    const nextY = gridStartY + next.row * cellSize + cellSize / 2;
                    const currX = x + cellSize / 2;
                    const currY = y + cellSize / 2;
                    
                    ctx.strokeStyle = 'rgba(33, 150, 243, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(currX, currY);
                    ctx.lineTo(nextX, nextY);
                    ctx.stroke();
                }
            }
        });
        
        // 繪製障礙物（深灰色）
        walls.forEach(cell => {
            const x = gridStartX + cell.col * cellSize;
            const y = gridStartY + cell.row * cellSize;
            ctx.fillStyle = 'rgba(33, 33, 33, 0.8)';
            ctx.fillRect(x, y, cellSize, cellSize);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, cellSize, cellSize);
        });
        
        // 繪製起點（綠色，帶旗幟圖示）
        const startX = gridStartX + startPos.col * cellSize;
        const startY = gridStartY + startPos.row * cellSize;
        ctx.fillStyle = 'rgba(76, 175, 80, 0.9)';
        ctx.fillRect(startX, startY, cellSize, cellSize);
        ctx.strokeStyle = 'rgba(56, 142, 60, 1)';
        ctx.lineWidth = 2;
        ctx.strokeRect(startX, startY, cellSize, cellSize);
        ctx.fillStyle = 'white';
        ctx.font = `bold ${Math.floor(cellSize * 0.6)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('S', startX + cellSize / 2, startY + cellSize / 2);
        
        // 繪製終點（紅色，帶目標圖示）
        const endX = gridStartX + endPos.col * cellSize;
        const endY = gridStartY + endPos.row * cellSize;
        ctx.fillStyle = 'rgba(244, 67, 54, 0.9)';
        ctx.fillRect(endX, endY, cellSize, cellSize);
        ctx.strokeStyle = 'rgba(198, 40, 40, 1)';
        ctx.lineWidth = 2;
        ctx.strokeRect(endX, endY, cellSize, cellSize);
        ctx.fillStyle = 'white';
        ctx.fillText('E', endX + cellSize / 2, endY + cellSize / 2);
        
        // 繪製圖例（位置緊貼網格下方，避免超出畫布）
        const legendY = gridStartY + gridHeight + height * 0.04;
        const legendItems = [
            { color: 'rgba(76, 175, 80, 0.9)', label: '起點', x: width * 0.15 },
            { color: 'rgba(244, 67, 54, 0.9)', label: '終點', x: width * 0.35 },
            { color: 'rgba(33, 150, 243, 0.6)', label: '路徑', x: width * 0.55 },
            { color: 'rgba(76, 175, 80, 0.3)', label: '已探索', x: width * 0.75 }
        ];
        
        legendItems.forEach(item => {
            ctx.fillStyle = item.color;
            ctx.fillRect(item.x - 20, legendY - 8, 16, 16);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(item.x - 20, legendY - 8, 16, 16);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = `${Math.floor(width / 60)}px "Microsoft YaHei", sans-serif`;
            ctx.textAlign = 'left';
            ctx.fillText(item.label, item.x + 2, legendY + 4);
        });
    }
    
    // 生成排序演算法預覽圖
    function generateSortingPreview() {
        const canvas = document.getElementById('sorting-preview');
        if (!canvas) return;
        
        // 設定 Canvas 尺寸（高解析度）
        const dpr = window.devicePixelRatio || 1;
        const container = canvas.parentElement;
        const displayWidth = container.clientWidth || 800;
        // 使用容器的实际高度（CSS aspect-ratio 会自动计算）
        const displayHeight = container.clientHeight || Math.floor(displayWidth * 9 / 16);
        
        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        
        const width = displayWidth;
        const height = displayHeight;
        
        // 建立漸層背景
        const bgGradient = ctx.createLinearGradient(0, 0, width, height);
        bgGradient.addColorStop(0, '#667eea');
        bgGradient.addColorStop(1, '#764ba2');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, width, height);
        
        // 绘制标题
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = `bold ${Math.floor(width / 25)}px "Microsoft YaHei", sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText('排序演算法視覺化', width / 2, height * 0.12);
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = `${Math.floor(width / 45)}px "Microsoft YaHei", sans-serif`;
        ctx.fillText('5 種常見排序演算法', width / 2, height * 0.21);
        
        // 生成示例陣列資料（模擬已排序狀態）
        const arraySize = 12;
        const maxValue = 200;
        const array = Array.from({ length: arraySize }, (_, i) => 
            Math.floor((i + 1) * (maxValue / arraySize))
        );
        
        // 繪製區域設定
        const chartArea = {
            x: width * 0.1,
            y: height * 0.3,
            width: width * 0.8,
            height: height * 0.5
        };
        
        const barWidth = chartArea.width / arraySize;
        const maxBarHeight = chartArea.height * 0.8;
        const spacing = barWidth * 0.1;
        const actualBarWidth = barWidth - spacing;
        
        // 繪製排序長條圖
        array.forEach((value, index) => {
            const barHeight = (value / maxValue) * maxBarHeight;
            const x = chartArea.x + index * barWidth + spacing / 2;
            const y = chartArea.y + maxBarHeight - barHeight;
            
            // 创建柱状图渐变
            const barGradient = ctx.createLinearGradient(x, y, x, y + barHeight);
            const hue = (index / arraySize) * 60 + 180; // 从蓝到紫的渐变
            barGradient.addColorStop(0, `hsl(${hue}, 70%, 60%)`);
            barGradient.addColorStop(1, `hsl(${hue}, 70%, 45%)`);
            
            ctx.fillStyle = barGradient;
            ctx.fillRect(x, y, actualBarWidth, barHeight);
            
            // 繪製數值標籤（僅在寬度足夠時顯示）
            if (width > 400) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = `bold ${Math.floor(width / 55)}px "Microsoft YaHei", sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(value, x + actualBarWidth / 2, y - 5);
            }
            
            // 繪製邊框高光
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, actualBarWidth, barHeight);
        });
        
        // 繪製演算法標籤
        const algorithms = ['冒泡', '快速', '歸併', '選擇', '插入'];
        const labelY = chartArea.y + maxBarHeight + height * 0.075;
        const labelSpacing = chartArea.width / algorithms.length;
        
        algorithms.forEach((name, index) => {
            const x = chartArea.x + index * labelSpacing + labelSpacing / 2;
            
            // 繪製小圖示
            ctx.fillStyle = `hsl(${180 + index * 15}, 70%, 55%)`;
            ctx.beginPath();
            ctx.arc(x, labelY - height * 0.02, width * 0.015, 0, Math.PI * 2);
            ctx.fill();
            
            // 繪製文字
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = `${Math.floor(width / 55)}px "Microsoft YaHei", sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(name, x, labelY + height * 0.03);
        });
        
        // 繪製裝飾性元素
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(chartArea.x, chartArea.y + maxBarHeight);
        ctx.lineTo(chartArea.x + chartArea.width, chartArea.y + maxBarHeight);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // 頁面載入完成後生成預覽圖
    let resizeTimer;
    function generateAllPreviews() {
        // 使用 requestAnimationFrame 確保 DOM 和 CSS 已完全渲染
        requestAnimationFrame(() => {
            generateAStarPreview();
            generateSortingPreview();
        });
    }
    
    window.addEventListener('DOMContentLoaded', () => {
        generateAllPreviews();

        // 讓整張卡片可點擊，導向主要連結
        const cards = document.querySelectorAll('.card[data-href]');
        cards.forEach(card => {
            card.setAttribute('tabindex', '0');
            card.setAttribute('role', 'link');

            card.addEventListener('click', (event) => {
                // 若點到的是內部的 <a>，交給原本連結處理
                const target = event.target;
                if (target.closest('a')) {
                    return;
                }
                const href = card.getAttribute('data-href');
                if (href) {
                    window.location.href = href;
                }
            });

            card.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    card.click();
                }
            });
        });
    });
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(generateAllPreviews, 250);
    });
    
    // 確保在圖片載入後也重新生成（如果有其他資源）
    window.addEventListener('load', generateAllPreviews);
</script>
</body>
</html>

